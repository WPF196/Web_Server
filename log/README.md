同步/异步日志系统
===============
同步/异步日志系统主要涉及了两个模块，一个是日志模块，一个是阻塞队列模块,其中加入阻塞队列模块主要是为解决异步写入日志做准备.
> * 自定义阻塞队列
> * `单例模式`创建日志
> * 同步日志
> * 异步日志
> * 实现按天、超行分类 
----------------------------------
### 基础知识
>* **日志**：由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。
>* **同步日志**：日志写入函数与工作线程串行执行，由于涉及到I/O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。
>* **生产者-消费者模型**：并发编程中的经典模型。以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓冲区中pop消息。
>* **阻塞队列**：将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区。
>* **异步日志**：将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。
>* **单例模式**：保证一个类只创建一个实例，同时提供全局访问
----------------------------------
### 单例模式
实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。

=========================================================================
#### 1. 懒汉模式（双检测，用时创建）
```
class single{
 private:
    // 私有静态指针变量指向唯一实例
    static single *p;  
     
    // 静态锁，是由于静态函数只能访问静态成员
    static pthread_mutex_t lock; 
 
     // 私有化构造函数
    single(){
        pthread_mutex_init(&lock, NULL);
    }
    ~single(){}

public:
    // 公有静态方法获取实例
    static single* getinstance();

};

pthread_mutex_t single::lock;
single* single::p = NULL;
single* single::getinstance(){
    if (NULL == p){           // 检测1
        pthread_mutex_lock(&lock);  // 检测2
        if (NULL == p){             // 用时创建对象
            p = new single;
        }
        pthread_mutex_unlock(&lock);
    }
    return p;
}
```
#### 为什么要用双检测，只检测一次不行吗？
> 如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合NULL == p的情况，直接返回已创建好的实例。
#### 注：c++11后要求编译器保证内部静态变量的线程安全性，所以无需手动加锁
* 优点：第一次使用实例对象时，创建对象。进程启动无负载。多个单例实例启动顺序自由控制。
* 缺点：复杂 

=========================================================================
#### 1. 饿汉模式（单例类定义之后，实例对象就已经存在了）
饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。
```
class single{
private:
    static single* p;
    single(){}
    ~single(){}

public:
    static single* getinstance();

};
single* single::p = new single();   // 直接创建对象
single* single::getinstance(){      // 返回所创建的对象
    return p;
}
```
* 优点：简单
* 缺点：可能会导致进程启动慢，且如果有多个单例类对象实例启动顺序不确定。非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。